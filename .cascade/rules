# Publer API Python Client - Development Rules

## Project Overview
This is a Python client library for the Publer API (https://publer.com/docs).
The library provides a modern, type-safe interface for interacting with Publer's social media management platform.

## Technology Stack
- **Python**: 3.8+ (use type hints throughout)
- **HTTP Client**: httpx (NOT requests) - for HTTP/2 and async support
- **Data Validation**: Pydantic v2 for models and validation
- **Testing**: pytest with pytest-asyncio for async tests
- **Code Quality**: black, isort, mypy, ruff

## Development Environment
- **Conda Environment**: `publer`
- Always activate the conda environment before running commands:
  ```bash
  conda activate publer
  ```
- All Python commands, tests, and package installations should use this environment
- When running commands, ensure the `publer` environment is active

## Architecture Pattern

### Core Structure
```
publer/
├── __init__.py          # Package exports
├── client.py            # Main PublerClient and AsyncPublerClient classes
├── session.py           # HTTP session management (httpx wrapper)
├── exceptions.py        # Custom exception hierarchy
├── models/              # Pydantic models for API data
│   ├── __init__.py
│   ├── posts.py
│   ├── accounts.py
│   ├── analytics.py
│   ├── media.py
│   └── workspaces.py
├── resources/           # API resource classes (one per major endpoint group)
│   ├── __init__.py
│   ├── base.py          # BaseResource with common functionality
│   ├── posts.py
│   ├── accounts.py
│   ├── analytics.py
│   ├── media.py
│   └── workspaces.py
└── utils/
    ├── __init__.py
    ├── rate_limit.py    # Rate limiting logic
    └── polling.py       # Job polling for async operations
```
### Project Status

See `PROJECT_STATUS.md` for current implementation status.
Update `PROJECT_STATUS.md` after making changes to the project.

### Design Principles

1. **Session/Client/Exceptions Pattern**
   - `session.py`: Wraps httpx.Client/AsyncClient, handles auth headers, base URL, retries
   - `client.py`: Main entry point, instantiates resource classes
   - `exceptions.py`: Custom exceptions mapped from HTTP status codes
   - `resources/*.py`: Each resource class handles a group of related endpoints

2. **Resource-Based Organization**
   - Use: `client.posts.create()` NOT `client.create_post()`
   - Each resource inherits from BaseResource
   - Resources are lazy-loaded properties on the client

3. **Type Safety**
   - All public methods must have type hints
   - Use Pydantic models for request/response data
   - Enable strict mypy checking

4. **Async Support**
   - Provide both sync (PublerClient) and async (AsyncPublerClient) versions
   - Use the same resource classes with async/sync session detection
   - All I/O operations should support both modes

## Coding Standards

### Imports
```python
# Standard library
import os
from typing import Optional, List, Dict, Any

# Third-party
import httpx
from pydantic import BaseModel, Field

# Local
from publer.exceptions import PublerAPIError
from publer.models.posts import Post, PostCreate
```

### Pydantic Models
```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class Post(BaseModel):
    """A Publer post."""
    
    id: str = Field(..., description="Unique post identifier")
    text: str = Field(..., description="Post content")
    state: str = Field(..., description="Post state: scheduled, published, draft")
    scheduled_at: Optional[datetime] = Field(None, description="Scheduled publish time")
    
    class Config:
        # Use v2 style config
        from_attributes = True
        populate_by_name = True
```

### Resource Classes
```python
from typing import List, Optional
from publer.resources.base import BaseResource
from publer.models.posts import Post, PostCreate

class PostsResource(BaseResource):
    """Posts API endpoints."""
    
    def create(self, post: PostCreate) -> Post:
        """Create a new post.
        
        Args:
            post: Post data
            
        Returns:
            Created post
            
        Raises:
            ValidationError: Invalid post data
            RateLimitError: Rate limit exceeded
        """
        response = self._request(
            "POST",
            "/posts",
            json=post.model_dump(exclude_none=True)
        )
        return Post(**response)
    
    def list(
        self,
        state: Optional[str] = None,
        limit: int = 50,
        offset: int = 0
    ) -> List[Post]:
        """List posts with optional filters."""
        params = {"limit": limit, "offset": offset}
        if state:
            params["state"] = state
            
        response = self._request("GET", "/posts", params=params)
        return [Post(**item) for item in response["posts"]]
```

### Exception Handling
```python
# exceptions.py structure
class PublerAPIError(Exception):
    """Base exception for all Publer API errors."""
    
    def __init__(self, message: str, status_code: Optional[int] = None, response: Optional[dict] = None):
        self.message = message
        self.status_code = status_code
        self.response = response
        super().__init__(self.message)

class AuthenticationError(PublerAPIError):
    """401 Unauthorized."""
    pass

class RateLimitError(PublerAPIError):
    """429 Too Many Requests."""
    
    def __init__(self, message: str, retry_after: Optional[int] = None, **kwargs):
        super().__init__(message, **kwargs)
        self.retry_after = retry_after

# Map status codes to exceptions
ERROR_MAP = {
    400: ValidationError,
    401: AuthenticationError,
    403: ForbiddenError,
    404: NotFoundError,
    429: RateLimitError,
    500: ServerError,
}
```

### Session Management
```python
# Use httpx, not requests
class PublerSession:
    """HTTP session for Publer API."""
    
    def __init__(
        self,
        api_key: str,
        base_url: str = "https://app.publer.com/api/v1",
        workspace_id: Optional[str] = None,
        timeout: float = 30.0
    ):
        self.api_key = api_key
        self.base_url = base_url
        self.workspace_id = workspace_id
        
        self.client = httpx.Client(
            base_url=base_url,
            timeout=timeout,
            headers=self._build_headers()
        )
    
    def _build_headers(self) -> dict:
        headers = {
            "Authorization": f"Bearer-API {self.api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }
        if self.workspace_id:
            headers["Publer-Workspace-Id"] = self.workspace_id
        return headers
```

## API-Specific Rules

### Authentication
- API key must be passed as `Bearer-API {token}` in Authorization header
- Workspace ID goes in `Publer-Workspace-Id` header when required
- Never log or print API keys

### Rate Limiting
- Limit: 100 requests per 2 minutes per user
- Implement automatic retry with exponential backoff
- Expose rate limit info to users via response headers

### Async Operations
- Some endpoints return `{"job_id": "..."}` instead of immediate results
- Implement polling utility: `poll_job_status(job_id, timeout=60, interval=2)`
- Allow users to opt-out of auto-polling

### Timestamps
- All timestamps use ISO 8601 format: `YYYY-MM-DDThh:mm:ss±hh:mm`
- Use Python's `datetime` with timezone info
- Pydantic handles parsing automatically

### Error Responses
```json
{
  "errors": ["Error message 1", "Error message 2"]
}
```
- Parse errors array and join messages
- Include full response in exception for debugging

## Testing Guidelines

### Test Structure
```
tests/
├── conftest.py          # Shared fixtures
├── test_client.py       # Client initialization tests
├── test_session.py      # Session tests
├── test_posts.py        # Posts resource tests
├── test_analytics.py    # Analytics tests
└── test_async.py        # Async client tests
```

### Fixtures
```python
import pytest
from publer import PublerClient

@pytest.fixture
def mock_api_key():
    return "test_api_key_12345"

@pytest.fixture
def client(mock_api_key):
    return PublerClient(api_key=mock_api_key)

@pytest.fixture
def mock_httpx(respx_mock):
    """Mock httpx requests."""
    return respx_mock
```

### Test Example
```python
def test_create_post(client, mock_httpx):
    # Mock the API response
    mock_httpx.post("/posts").mock(
        return_value=httpx.Response(
            200,
            json={"id": "post_123", "text": "Hello", "state": "scheduled"}
        )
    )
    
    # Test the method
    post = client.posts.create(text="Hello", accounts=["acc_1"])
    
    assert post.id == "post_123"
    assert post.text == "Hello"
```

## Documentation Standards

### Docstrings
- Use Google-style docstrings
- Document all public methods, classes, and modules
- Include examples for complex operations

```python
def create_post(
    self,
    text: str,
    accounts: List[str],
    scheduled_at: Optional[datetime] = None,
    media_urls: Optional[List[str]] = None
) -> Post:
    """Create a new social media post.
    
    Args:
        text: Post content text
        accounts: List of account IDs to post to
        scheduled_at: When to publish (None for immediate)
        media_urls: Optional list of media URLs to attach
        
    Returns:
        Created post object with ID and metadata
        
    Raises:
        ValidationError: If post data is invalid
        RateLimitError: If rate limit is exceeded
        AuthenticationError: If API key is invalid
        
    Example:
        >>> post = client.posts.create(
        ...     text="Hello world!",
        ...     accounts=["acc_123"],
        ...     scheduled_at=datetime(2025, 10, 15, 10, 0, 0)
        ... )
        >>> print(post.id)
        post_abc123
    """
```

## Dependencies

### Core
```toml
[project]
dependencies = [
    "httpx>=0.27.0",
    "pydantic>=2.0.0",
    "python-dateutil>=2.8.0",
]
```

### Development
```toml
[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.0.0",
    "respx>=0.20.0",  # For mocking httpx
    "black>=23.0.0",
    "isort>=5.12.0",
    "mypy>=1.0.0",
    "ruff>=0.1.0",
]
```

## Common Pitfalls to Avoid

1. **Don't use requests** - Use httpx for modern HTTP/2 and async support
2. **Don't hardcode URLs** - Use base_url + endpoint paths
3. **Don't ignore rate limits** - Implement proper handling
4. **Don't skip type hints** - They're required for all public APIs
5. **Don't forget async variants** - Provide both sync and async
6. **Don't expose raw HTTP responses** - Return Pydantic models
7. **Don't swallow exceptions** - Let them bubble up with context

## Performance Considerations

1. **Connection Pooling**: httpx.Client reuses connections automatically
2. **Timeouts**: Set reasonable defaults (30s), allow user override
3. **Pagination**: Implement cursor-based pagination for large result sets
4. **Caching**: Consider caching workspace/account lists (they change rarely)
5. **Batch Operations**: Use bulk endpoints when available

## Security Best Practices

1. Never log API keys or tokens
2. Use environment variables for credentials in examples
3. Validate all user input before sending to API
4. Don't store sensitive data in exceptions
5. Use HTTPS only (enforced by base URL)

## Maintenance

- Keep dependencies updated (especially httpx and pydantic)
- Monitor Publer API changelog for breaking changes
- Add deprecation warnings before removing features
- Follow semantic versioning strictly
